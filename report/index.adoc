= The Report

== Introduction

During the course DevOps, Software Evolution and Software Maintenance an application stemming from an earlier course
has been subjected to a simulation simulating real world usage by users. This has forced us to make the application more
durable, more performant, and more maintainable. This has taught us to develop more performant applications, implement 
robust CI/CD workflows, and to use metrics, monitoring and logging to monitor, and keep our application healthy.

== System's Perspective

=== Design and Architecture of ITU-MiniTwit Systems

// Description and illustration of the design and architecture.

=== Dependencies of ITU-MiniTwit Systems

// List and brief description of all technologies and tools applied and depended on.
* ASP.NET Core: The foundation of our application, used for implementing the web server, user authorization and identification, and our minimal web API.
* Entity Framework: Used for the database abstraction layer and all CRUD operation logic.
* Playwright: A testing library enabling end-to-end (E2E) tests.
* Prometheus: Monitoring system and time-series database for collecting and querying metrics.
* Xunit: A testing library for integration and unit testing.
* Coverlet: A tool for determining code coverage in tests.
* Moq: A test library for generating mock objects for unit testing.

=== Important Interactions of Subsystems

// Description of important interactions of subsystems.

=== Current State of Systems

// Description of the current state of systems.

== Process' Perspective

=== CI/CD Chains

// Description of stages and tools included in the CI/CD chains.

=== System Monitoring

// Description of how the systems are monitored and what is monitored.

=== System Logging

We initially tried deploying the ELK stack for logging and monitoring but faced difficulties. 
We then chose New Relic, which logs everything written to a the node's console, similar to local debugging. 
It logs stack traces, exception messages, and preceding events when requests fail, allowing us to monitor API access, 
track server actions, and identify errors.

The aggregated logs where sent to New Relic and were accessible through their propriotary dashboard.

We configured the New Relic agent in our Dockerfile, ensuring consistent logging across all application nodes.

=== Security Assessment

// Brief results of the security assessment and description of how the system security was hardened.

=== Scaling and Upgrades Strategy

// Description of the applied strategy for scaling and upgrades.

=== Use of AI-Assistants
In this project these AI-assistants were used:

* OpenAI's ChatGPT version 3.5, 4.0.
* GitHub Copilot

The AI-assistants were mainly used for:

* Breaking down code logic. I.g. In order to recreate the Python API controller provided by the course, the code needed to be translated into C# and modified to fit our application. ChatGPT was a great tool for understanding each endpoint and what data would be included in a call and a response.
* Code completions. GitHub Copilot acted as an extension of IntelliSense, in the sense that it could auto-complete simple pieces of code, such as loops, if-statements, and method signatures.
* Research. ChatGPT was also used to provide a secondary explanation when researching new technologies, in situations were the documentation either was difficult to understand, or if subsidiary information was needed. 
* Stacktrace breakdowns. ChatGPT was used to breakdown stracktraces, summarizing the information as well as providing a more user-friendly format to read. 
* Identify functions that could be made more performant. 

Downsides of using AI-assistants:

* Both ChatGPT and Github Copilot are flawed, which makes them unreliable tools. Sometimes it would take as much time to double check the output of an assistant as would have to complete the task without it, which defeats the purpose of using them.
* If used without careful inspection of the provided code, the LLM is likely to introduce bugs into the application. This is due to the fact,
that LLM's have a difficult time understanding the context in which the requested code is supposed to operate.

// Description of the use of AI-assistants during the project.

== Lessons Learned Perspective

=== Evolution and Refactoring

// Description of the biggest issues, how they were solved, and lessons learned.

=== Operation

// Description of the biggest issues, how they were solved, and lessons learned.

=== Maintenance

// Description of the biggest issues, how they were solved, and lessons learned.

== DevOps Style of Work
As the entire team has been taking the course "Second Year Project: Software Development in Large Teams" which introduces working by the Agile principles and with Scrum as a framework, it's only natural that some elements has been taken into the project. Especially since these frameworks align well with the DevOps style of work.

Agile principles \\
Psychological safety \\
Pair/Mob programming \\
Kanban board/Github project board\\

Pair programming/mob programming \\


// Reflection and description of the "DevOps" style of work.

== Conclusion

// Brief conclusion of the report.

== References

// List of references.
